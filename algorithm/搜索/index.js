// 6.1 算法解释
// 深度优先搜索和广度优先搜索是两种最常见的优先搜索方法，它们被广泛地运用在图和树等
// 结构中进行搜索。
// 6.2 深度优先搜索
// 深度优先搜索（depth-first seach，DFS）在搜索到一个新的节点时，立即对该新节点进行遍
// 历；因此遍历需要用先入后出的栈来实现，也可以通过与栈等价的递归来实现。对于树结构而言，
// 由于总是对新节点调用遍历，因此看起来是向着“深”的方向前进。
// 考虑如下一颗简单的树。我们从 1 号节点开始遍历，假如遍历顺序是从左子节点到右子节点，
// 那么按照优先向着“深”的方向前进的策略，假如我们使用递归实现，我们的遍历过程为 1（起
// 始节点）->2（遍历更深一层的左子节点）->4（遍历更深一层的左子节点）->2（无子节点，返回
// 父结点）->1（子节点均已完成遍历，返回父结点）->3（遍历更深一层的右子节点）->1（无子节
// 点，返回父结点）-> 结束程序（子节点均已完成遍历）。如果我们使用栈实现，我们的栈顶元素
// 的变化过程为 1->2->4->3。

// 深度优先搜索也可以用来检测环路：记录每个遍历过的节点的父节点，若一个节点被再次遍
// 历且父节点不同，则说明有环。我们也可以用之后会讲到的拓扑排序判断是否有环路，若最后存
// 在入度不为零的点，则说明有环。
// 有时我们可能会需要对已经搜索过的节点进行标记，以防止在遍历时重复搜索某个节点，这
// 种做法叫做状态记录或记忆化（memoization）。

// 695. Max Area of Island (Easy)
// 题目描述
// 给定一个二维的 0-1 矩阵，其中 0 表示海洋，1 表示陆地。单独的或相邻的陆地可以形成岛
// 屿，每个格子只与其上下左右四个格子相邻。求最大的岛屿面积。
// 6.2 深度优先搜索 – 25/143 –
// 输入输出样例
// 输入是一个二维数组，输出是一个整数，表示最大的岛屿面积。
// Input:
// [[1,0,1,1,0,1,0,1],
// [1,0,1,1,0,1,1,1],
// [0,0,0,0,0,0,0,1]]
// Output: 6
// 最大的岛屿面积为 6，位于最右侧。
/**
 *
 * @param {Array<number[]>} grid
 */
function maxAreaOfIsland(grid) {
  let area = 0,
    maxArea = 0

  for (let i = 0; i < grid.length; i++) {
    for (let j = 0; j < grid[i].length; j++) {
      if (grid[i][j] === 1) {
        area = getArea(grid, i, j)
        maxArea = Math.max(maxArea, area)
      }
    }
  }

  return maxArea
}

function getArea(grid, i, j) {
  if (i < 0) return 0
  if (j < 0) return 0
  if (i >= grid.length) return 0
  if (j >= grid[i].length) return 0
  if (grid[i][j] === 1) {
    grid[i][j] = 0
    return (
      1 +
      getArea(grid, i - 1, j) +
      getArea(grid, i + 1, j) +
      getArea(grid, i, j + 1) +
      getArea(grid, i, j - 1)
    )
  }

  return 0
}

console.log(
  maxAreaOfIsland([
    [1, 0, 1, 1, 0, 1, 0, 1],
    [1, 0, 1, 1, 0, 1, 1, 1],
    [0, 0, 0, 0, 0, 0, 0, 1],
  ])
)
